---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 04-adv-regex-patterns.md in _episodes_rmd/
title: Advanced regular expression patterns
teaching: 25
exercises: 30
objectives:
- "Learn how to escape special symbols to match them exactly"
- "Understand what predefined shortcuts exist to simplify regex patterns"
- "Use backreferences to refer to matched groups"
keypoints:
- "To find literal matches for any of these special characters, escape them with `\\`"
- "To escape characters in R, you need to escape them twice"
- "There are a number of shortcut symbols to make writing regex patterns easier"
- "These include `\\w`, `\\s`, `\\d`, and `\\b` for words, spaces, digits and boundaries"
- "The uppercase versions of these are the inverse matches (`\\W`, `\\S`, etc)"
- "Text matched within a grouping using `()` can be referred to using `\\1` for the first group, `\\2` for the second"
- "In R, each of these patterns need the `\\` to be escaped again to be written as a string."
source: Rmd
---



The previous elements will be enough to create almost any regex pattern you need. However in certain
circumstances more advanced features may be needed to construct a matching pattern.

## Ignoring special symbol behaviour
We have introduced several symbols that have special meaning in regular expression patterns
(like `.` for 'any character'). But what if the text you are trying to match contains those
characters? 


~~~
birds %>% 
  mutate(has_dot = str_detect(location, "."))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location          date      species            count                  has_dot
   <chr>             <chr>     <chr>              <chr>                  <lgl>  
 1 Mount. Ainslie    21/12/19  Magpie             10                     TRUE   
 2 Black Mtn         09/02/20… Gang-gang cockatoo 2                      TRUE   
 3 Botanic Gardens   15/2/20   Magpie             1 (didn't see it, but… TRUE   
 4 LBG               7-12-19   Magpie-lark        4                      TRUE   
 5 Mt  Ainslie       16/2/20   Gang Gang cockatoo 2                      TRUE   
 6 Ainslie Oval      Last Sun… Sulphur-crested c… Eight                  TRUE   
 7 Lake Burley   Gr… 14/12/19  Crimson Rosella    4                      TRUE   
 8 Lake Burley Grif… 8/2/20    Gang gang cockatoo 9                      TRUE   
 9 Mt. Majura        23/2/20   Magpie lark        12                     TRUE   
10 Downer Oval       18/11/19  King-Parrot        6                      TRUE   
~~~
{: .output}

To match a symbol exactly we need a way to tell it to not use it's special behaviour. This is called
"escaping" the symbol, and is done by putting a `\` before the symbol.

This introduces a problem for using regex patterns in R, because we write the patterns using a 
string. Strings already use `\` for escaping characters, so our `\.` pattern gives an error. 


~~~
birds %>% 
  mutate(has_dot = str_detect(location, "\."))
~~~
{: .language-r}



~~~
Error: '\.' is an unrecognized escape in character string starting ""\."
~~~
{: .error}

To fix this, we actually need to escape the symbol **twice** when we are writing it.
The *string* `"\\."` creates the regular expression `\.`, which matches a literal `.` in our text


~~~
birds %>% 
  mutate(has_dot = str_detect(location, "\\."))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location          date      species            count                  has_dot
   <chr>             <chr>     <chr>              <chr>                  <lgl>  
 1 Mount. Ainslie    21/12/19  Magpie             10                     TRUE   
 2 Black Mtn         09/02/20… Gang-gang cockatoo 2                      FALSE  
 3 Botanic Gardens   15/2/20   Magpie             1 (didn't see it, but… FALSE  
 4 LBG               7-12-19   Magpie-lark        4                      FALSE  
 5 Mt  Ainslie       16/2/20   Gang Gang cockatoo 2                      FALSE  
 6 Ainslie Oval      Last Sun… Sulphur-crested c… Eight                  FALSE  
 7 Lake Burley   Gr… 14/12/19  Crimson Rosella    4                      FALSE  
 8 Lake Burley Grif… 8/2/20    Gang gang cockatoo 9                      FALSE  
 9 Mt. Majura        23/2/20   Magpie lark        12                     TRUE   
10 Downer Oval       18/11/19  King-Parrot        6                      FALSE  
~~~
{: .output}

> ## Finding something special
> The grouping characters -- `(` and `)` -- are special symbols in regex patterns. What string do 
> you need to write in R to match a `(` character?
> 
> 1. `"("`
> 2. `"\("`
> 3. `"\\("`
>
> Write a regex pattern using `str_extract()` that will extract the entire bracketed statement in the 
> `count` column of the birds data.
{: .challenge}

## Shorthand symbols

Certain combinations of characters are common enough that there are shortcuts available to reduce
typing in your regex patterns and make them a bit more readable. Each of these shortcuts is formed 
by escaping certain letters.

* `\w` for **word characters**: Any alphanumeric character, or an underscore. Equivalent to
`[a-zA-Z0-9_]`

> ## Double escaping
> As with the discussion above, the regex pattern for any word character is `\w` with an escape 
> character. This means that in R, we need to escape the pattern again when writing it as a string 
> -- `"\\w"`. You will see these notes using the regex pattern (`\w`) when discussing the symbols, 
> but the code examples will show how to use these patterns in a string (`"\\w"`).
{: .callout}

* `\s` for **space characters**: Any whitespace characters. Spaces, tabs, etc.

* `\d` for **digits**: Any numeric character. Equivalent to `[0-9]`

The reverse of these shortcuts can be matched by capitalising the letter. 
Eg: `\W` for NOT a word character


~~~
birds %>% 
  mutate(double_space = str_detect(location, "\\w\\s\\s\\w"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location         date      species          count                double_space
   <chr>            <chr>     <chr>            <chr>                <lgl>       
 1 Mount. Ainslie   21/12/19  Magpie           10                   FALSE       
 2 Black Mtn        09/02/20… Gang-gang cocka… 2                    FALSE       
 3 Botanic Gardens  15/2/20   Magpie           1 (didn't see it, b… FALSE       
 4 LBG              7-12-19   Magpie-lark      4                    FALSE       
 5 Mt  Ainslie      16/2/20   Gang Gang cocka… 2                    TRUE        
 6 Ainslie Oval     Last Sun… Sulphur-crested… Eight                FALSE       
 7 Lake Burley   G… 14/12/19  Crimson Rosella  4                    FALSE       
 8 Lake Burley Gri… 8/2/20    Gang gang cocka… 9                    FALSE       
 9 Mt. Majura       23/2/20   Magpie lark      12                   FALSE       
10 Downer Oval      18/11/19  King-Parrot      6                    FALSE       
~~~
{: .output}



~~~
birds %>% 
  mutate(full_year = str_extract(date, "\\d{4}"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location          date      species           count                 full_year
   <chr>             <chr>     <chr>             <chr>                 <chr>    
 1 Mount. Ainslie    21/12/19  Magpie            10                    <NA>     
 2 Black Mtn         09/02/20… Gang-gang cockat… 2                     2020     
 3 Botanic Gardens   15/2/20   Magpie            1 (didn't see it, bu… <NA>     
 4 LBG               7-12-19   Magpie-lark       4                     <NA>     
 5 Mt  Ainslie       16/2/20   Gang Gang cockat… 2                     <NA>     
 6 Ainslie Oval      Last Sun… Sulphur-crested … Eight                 <NA>     
 7 Lake Burley   Gr… 14/12/19  Crimson Rosella   4                     <NA>     
 8 Lake Burley Grif… 8/2/20    Gang gang cockat… 9                     <NA>     
 9 Mt. Majura        23/2/20   Magpie lark       12                    <NA>     
10 Downer Oval       18/11/19  King-Parrot       6                     <NA>     
~~~
{: .output}

> ## Using shortcuts
>
> 1. Take the regex pattern you wrote for the 
[date challenge](../03-regex-patterns/index.html#dont-repeat-yourself) at the end of the last episode.
> Can you rewrite it using `\d` and `\D`?
> 
> 2. Using `str_extract()`, write a regex pattern that uses `\w` and `\s` to extract the *first* two
> words of each entry from the `location` column of the birds data.
> Is your result any different if you use `\S` and `\s` instead?
{: .challenge}

## Additional anchoring

Along with `^` for the start of a line and `$` for the end, there is an additional anchoring symbol.

`\b` represents a *boundary*. This is the transition between 'non-word' and 'word' characters, or 
vice versa. Like with `^` and `$`, `\b` does not match a specific character in the text but provides
information about the location of the text to match.


~~~
# Matching spaces sometimes won't work to find words
birds %>% 
  mutate(with_spaces = str_extract(species, "\\sgang\\s"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location         date      species           count                with_spaces
   <chr>            <chr>     <chr>             <chr>                <chr>      
 1 Mount. Ainslie   21/12/19  Magpie            10                    <NA>      
 2 Black Mtn        09/02/20… Gang-gang cockat… 2                     <NA>      
 3 Botanic Gardens  15/2/20   Magpie            1 (didn't see it, b…  <NA>      
 4 LBG              7-12-19   Magpie-lark       4                     <NA>      
 5 Mt  Ainslie      16/2/20   Gang Gang cockat… 2                     <NA>      
 6 Ainslie Oval     Last Sun… Sulphur-crested … Eight                 <NA>      
 7 Lake Burley   G… 14/12/19  Crimson Rosella   4                     <NA>      
 8 Lake Burley Gri… 8/2/20    Gang gang cockat… 9                    " gang "   
 9 Mt. Majura       23/2/20   Magpie lark       12                    <NA>      
10 Downer Oval      18/11/19  King-Parrot       6                     <NA>      
~~~
{: .output}



~~~
# Boundaries may help
birds %>% 
  mutate(with_boundaries = str_extract(species, "\\bgang\\b"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location        date      species          count              with_boundaries
   <chr>           <chr>     <chr>            <chr>              <chr>          
 1 Mount. Ainslie  21/12/19  Magpie           10                 <NA>           
 2 Black Mtn       09/02/20… Gang-gang cocka… 2                  gang           
 3 Botanic Gardens 15/2/20   Magpie           1 (didn't see it,… <NA>           
 4 LBG             7-12-19   Magpie-lark      4                  <NA>           
 5 Mt  Ainslie     16/2/20   Gang Gang cocka… 2                  <NA>           
 6 Ainslie Oval    Last Sun… Sulphur-crested… Eight              <NA>           
 7 Lake Burley   … 14/12/19  Crimson Rosella  4                  <NA>           
 8 Lake Burley Gr… 8/2/20    Gang gang cocka… 9                  gang           
 9 Mt. Majura      23/2/20   Magpie lark      12                 <NA>           
10 Downer Oval     18/11/19  King-Parrot      6                  <NA>           
~~~
{: .output}

`\b` can match the start or end of the line, as well as the start or end of words within
it.


~~~
birds %>% 
  mutate(starts_B = str_detect(location, "\\bB"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location          date      species            count                 starts_B
   <chr>             <chr>     <chr>              <chr>                 <lgl>   
 1 Mount. Ainslie    21/12/19  Magpie             10                    FALSE   
 2 Black Mtn         09/02/20… Gang-gang cockatoo 2                     TRUE    
 3 Botanic Gardens   15/2/20   Magpie             1 (didn't see it, bu… TRUE    
 4 LBG               7-12-19   Magpie-lark        4                     FALSE   
 5 Mt  Ainslie       16/2/20   Gang Gang cockatoo 2                     FALSE   
 6 Ainslie Oval      Last Sun… Sulphur-crested c… Eight                 FALSE   
 7 Lake Burley   Gr… 14/12/19  Crimson Rosella    4                     TRUE    
 8 Lake Burley Grif… 8/2/20    Gang gang cockatoo 9                     TRUE    
 9 Mt. Majura        23/2/20   Magpie lark        12                    FALSE   
10 Downer Oval       18/11/19  King-Parrot        6                     FALSE   
~~~
{: .output}


## Backreferences
As mentioned previously, grouping brackets -- `()` -- will 'capture' their match for us to reuse. 
This means that the text matched by a pattern within grouping brackets will be remembered and can
be referred to again later using a backreference.

The text matched by the first grouping bracket in a regex pattern can be referred to using the pattern
`\1`. These backreferences will be most useful when we come to replacing text, but can occasionally
be useful in matching patterns as well.

For example, we saw previously that we can't match doubled characters using the quantifier brackets 
-- `{}`:


~~~
birds %>% 
  mutate(doubled_up = str_extract(species, ".{2}"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location         date      species            count                doubled_up
   <chr>            <chr>     <chr>              <chr>                <chr>     
 1 Mount. Ainslie   21/12/19  Magpie             10                   Ma        
 2 Black Mtn        09/02/20… Gang-gang cockatoo 2                    Ga        
 3 Botanic Gardens  15/2/20   Magpie             1 (didn't see it, b… Ma        
 4 LBG              7-12-19   Magpie-lark        4                    Ma        
 5 Mt  Ainslie      16/2/20   Gang Gang cockatoo 2                    Ga        
 6 Ainslie Oval     Last Sun… Sulphur-crested c… Eight                Su        
 7 Lake Burley   G… 14/12/19  Crimson Rosella    4                    Cr        
 8 Lake Burley Gri… 8/2/20    Gang gang cockatoo 9                    Ga        
 9 Mt. Majura       23/2/20   Magpie lark        12                   Ma        
10 Downer Oval      18/11/19  King-Parrot        6                    Ki        
~~~
{: .output}

Instead, we can 'capture' a character using `()` and refer to the captured character with `\1`. So
the regex pattern `(.)\1` means "Match any character, followed by the character that was just matched".
In other words, any doubled character.


~~~
birds %>% 
  mutate(doubled_up = str_extract(species, "(.)\\1"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location         date      species            count                doubled_up
   <chr>            <chr>     <chr>              <chr>                <chr>     
 1 Mount. Ainslie   21/12/19  Magpie             10                   <NA>      
 2 Black Mtn        09/02/20… Gang-gang cockatoo 2                    oo        
 3 Botanic Gardens  15/2/20   Magpie             1 (didn't see it, b… <NA>      
 4 LBG              7-12-19   Magpie-lark        4                    <NA>      
 5 Mt  Ainslie      16/2/20   Gang Gang cockatoo 2                    oo        
 6 Ainslie Oval     Last Sun… Sulphur-crested c… Eight                oo        
 7 Lake Burley   G… 14/12/19  Crimson Rosella    4                    ll        
 8 Lake Burley Gri… 8/2/20    Gang gang cockatoo 9                    oo        
 9 Mt. Majura       23/2/20   Magpie lark        12                   <NA>      
10 Downer Oval      18/11/19  King-Parrot        6                    rr        
~~~
{: .output}

> ## Using backreferences
>
> 1. Extract the doubled *letters* from the `location` column of the birds data using backreferences.
> 
> 2. What is a regex pattern that would match two words that start with the same letter (note that 
> just the matched text is captured by grouping brackets, not any boundary information)? Test your 
> pattern out using `str_extract()` on the `species` and `location` column of the birds data.
{: .challenge}

## Multiple groupings

When there are multiple grouping brackets in a pattern, the text matched in the second group can be
referenced using `\2`, the third with `\3` and so on.


~~~
birds %>% 
  mutate(palindrome = str_extract(date, "(\\d)(\\d)\\W\\2\\1"))
~~~
{: .language-r}



~~~
# A tibble: 10 x 5
   location         date      species            count                palindrome
   <chr>            <chr>     <chr>              <chr>                <chr>     
 1 Mount. Ainslie   21/12/19  Magpie             10                   21/12     
 2 Black Mtn        09/02/20… Gang-gang cockatoo 2                    02/20     
 3 Botanic Gardens  15/2/20   Magpie             1 (didn't see it, b… <NA>      
 4 LBG              7-12-19   Magpie-lark        4                    <NA>      
 5 Mt  Ainslie      16/2/20   Gang Gang cockatoo 2                    <NA>      
 6 Ainslie Oval     Last Sun… Sulphur-crested c… Eight                <NA>      
 7 Lake Burley   G… 14/12/19  Crimson Rosella    4                    <NA>      
 8 Lake Burley Gri… 8/2/20    Gang gang cockatoo 9                    <NA>      
 9 Mt. Majura       23/2/20   Magpie lark        12                   <NA>      
10 Downer Oval      18/11/19  King-Parrot        6                    <NA>      
~~~
{: .output}

> ## What's going on
> Have a look at the output from the following two patterns:

~~~
birds %>% 
  mutate(
    pattern_one = str_detect(species, "(\\w)(\\w)\\1"),
    pattern_two = str_detect(species, "(\\w)(\\w)\\2")
  )
~~~
{: .language-r}



~~~
# A tibble: 10 x 6
   location       date     species       count           pattern_one pattern_two
   <chr>          <chr>    <chr>         <chr>           <lgl>       <lgl>      
 1 Mount. Ainslie 21/12/19 Magpie        10              FALSE       FALSE      
 2 Black Mtn      09/02/2… Gang-gang co… 2               TRUE        TRUE       
 3 Botanic Garde… 15/2/20  Magpie        1 (didn't see … FALSE       FALSE      
 4 LBG            7-12-19  Magpie-lark   4               FALSE       FALSE      
 5 Mt  Ainslie    16/2/20  Gang Gang co… 2               TRUE        TRUE       
 6 Ainslie Oval   Last Su… Sulphur-cres… Eight           TRUE        TRUE       
 7 Lake Burley  … 14/12/19 Crimson Rose… 4               FALSE       TRUE       
 8 Lake Burley G… 8/2/20   Gang gang co… 9               TRUE        TRUE       
 9 Mt. Majura     23/2/20  Magpie lark   12              FALSE       FALSE      
10 Downer Oval    18/11/19 King-Parrot   6               FALSE       TRUE       
~~~
{: .output}
> Why are the results different and what text is being matched by each? Check if you are correct by
> running them with `str_extract()` instead.
{: .challenge}
